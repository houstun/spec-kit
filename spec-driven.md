# 规格驱动开发 (SDD)

## 权力反转

几十年来，代码一直是王者。规格说明服务于代码——它们是我们搭建的脚手架，一旦"真正的工作"（编码）开始，就被丢弃了。我们编写 PRD 来指导开发，创建设计文档来指导实现，绘制图表来可视化架构。但这些始终从属于代码本身。代码是真理。其他一切，充其量只是良好的愿望。代码是真实的来源，随着代码的推进，规格说明很少能跟上步伐。由于资产（代码）和实现是一体的，如果不尝试从代码构建，就很难拥有并行实现。

规格驱动开发（SDD）颠覆了这种权力结构。规格说明不服务于代码——代码服务于规格说明。产品需求文档（PRD）不是实现的指南；它是生成实现的源头。技术计划不是指导编码的文档；它们是产生代码的精确定义。这不是我们构建软件方式的渐进式改进。这是对什么驱动开发的根本性重新思考。

规格说明与实现之间的差距自软件开发诞生以来就一直困扰着我们。我们尝试过用更好的文档、更详细的需求、更严格的流程来弥合它。这些方法失败了，因为它们接受差距是不可避免的。它们试图缩小差距，但从未消除它。SDD 通过使规格说明及其从规格说明中诞生的具体实现计划变得可执行来消除差距。当规格说明和实现计划生成代码时，就没有差距——只有转换。

这种转换现在成为可能，是因为 AI 可以理解和实现复杂的规格说明，并创建详细的实现计划。但没有结构的原始 AI 生成会产生混乱。SDD 通过规格说明和随后的实现计划提供这种结构，这些计划足够精确、完整和明确，可以生成工作系统。规格说明成为主要工件。代码成为它在特定语言和框架中的表达（作为实现计划的实现）。

在这个新世界中，维护软件意味着演进规格说明。开发团队的意图以自然语言表达（"**意图驱动开发**"）、设计资产、核心原则和其他指南。开发的**通用语言**上升到更高的层次，代码是最后一英里的方法。

调试意味着修复生成错误代码的规格说明及其实现计划。重构意味着为了清晰而重新组织结构。整个开发工作流围绕规格说明作为中心真实来源重新组织，实现计划和代码作为持续再生的输出。用新功能更新应用程序或创建新的并行实现（因为我们是有创造力的存在），意味着重新审视规格说明并创建新的实现计划。因此，这个过程是 0 -> 1, (1', ..), 2, 3, N。

开发团队专注于他们的创造力、实验和批判性思维。

## SDD 工作流实践

工作流从一个想法开始——通常是模糊和不完整的。通过与 AI 的迭代对话，这个想法变成一份全面的 PRD。AI 提出澄清问题，识别边缘情况，并帮助定义精确的验收标准。在传统开发中可能需要数天会议和文档的工作，在数小时的专注规格说明工作中完成。这改变了传统的 SDLC——需求和设计成为持续的活动，而不是离散的阶段。这支持**团队流程**，其中团队审查的规格说明被表达和版本化，在分支中创建，然后合并。

当产品经理更新验收标准时，实现计划会自动标记受影响的技术决策。当架构师发现更好的模式时，PRD 会更新以反映新的可能性。

在整个规格说明过程中，研究代理收集关键上下文。他们调查库兼容性、性能基准和安全影响。组织约束被自动发现和应用——你公司的数据库标准、认证要求和部署策略无缝集成到每个规格说明中。

从 PRD，AI 生成将需求映射到技术决策的实现计划。每个技术选择都有记录的理由。每个架构决策都追溯到特定的需求。在整个过程中，一致性验证持续提高质量。AI 分析规格说明中的歧义、矛盾和差距——不是作为一次性关卡，而是作为持续的改进。

一旦规格说明及其实现计划足够稳定，代码生成就会开始，但它们不必是"完整的"。早期的生成可能是探索性的——测试规格说明在实践中是否有意义。领域概念成为数据模型。用户故事成为 API 端点。验收场景成为测试。这通过规格说明合并了开发和测试——测试场景不是在代码之后编写的，它们是规格说明的一部分，同时生成实现和测试。

反馈循环延伸到初始开发之外。生产指标和事件不仅仅触发热修复——它们为下一次再生更新规格说明。性能瓶颈成为新的非功能性需求。安全漏洞成为影响所有未来生成的约束。规格说明、实现和运营现实之间的这种迭代舞蹈是真正理解出现的地方，也是传统 SDLC 转变为持续演进的地方。

## 为什么 SDD 现在很重要

三个趋势使 SDD 不仅成为可能，而且成为必要：

首先，AI 能力已达到一个阈值，自然语言规格说明可以可靠地生成工作代码。这不是要取代开发人员——而是通过自动化从规格说明到实现的机械翻译来放大他们的效率。它可以放大探索和创造力，支持轻松"重新开始"，并支持添加、删除和批判性思维。

其次，软件复杂性继续呈指数级增长。现代系统集成了数十个服务、框架和依赖项。通过手动流程使所有这些部分与原始意图保持一致变得越来越困难。SDD 通过规格驱动的生成提供系统性的对齐。框架可能会演进为提供 AI 优先的支持，而不是人类优先的支持，或者围绕可重用组件进行架构设计。

第三，变化的步伐加快。需求变化的速度比以往任何时候都快得多。转型不再是例外——而是预期。现代产品开发要求基于用户反馈、市场条件和竞争压力进行快速迭代。传统开发将这些变化视为干扰。每次转型都需要手动将变化传播到文档、设计和代码中。结果要么是缓慢、谨慎的更新限制了速度，要么是快速、鲁莽的变化积累了技术债务。

SDD 可以支持假设/模拟实验："如果我们需要重新实现或更改应用程序以促进销售更多 T 恤的业务需求，我们将如何实现和实验？"

SDD 将需求变更从障碍转变为正常工作流。当规格说明驱动实现时，转型变成系统性的再生，而不是手动重写。在 PRD 中更改核心需求，受影响的实现计划会自动更新。修改用户故事，相应的 API 端点会重新生成。这不仅仅是关于初始开发——而是关于在不可避免的变化中保持工程速度。

## 核心原则

**规格说明作为通用语言**：规格说明成为主要工件。代码成为它在特定语言和框架中的表达。维护软件意味着演进规格说明。

**可执行的规格说明**：规格说明必须足够精确、完整和明确，以生成工作系统。这消除了意图和实现之间的差距。

**持续改进**：一致性验证持续进行，而不是作为一次性关卡。AI 作为持续过程分析规格说明中的歧义、矛盾和差距。

**研究驱动的上下文**：研究代理在整个规格说明过程中收集关键上下文，调查技术选项、性能影响和组织约束。

**双向反馈**：生产现实为规格说明演进提供信息。指标、事件和运营学习成为规格说明改进的输入。

**探索性分支**：从同一规格说明生成多个实现方法，以探索不同的优化目标——性能、可维护性、用户体验、成本。

## 实现方法

今天，实践 SDD 需要组装现有工具并在整个过程中保持纪律。该方法可以通过以下方式实践：

- 用于迭代规格说明开发的 AI 助手
- 用于收集技术上下文的研究代理
- 用于将规格说明转换为实现的代码生成工具
- 适应规格优先工作流的版本控制系统
- 通过 AI 分析规格说明文档进行一致性检查

关键是将规格说明视为真实来源，代码作为生成的输出服务于规格说明，而不是相反。

## 使用命令简化 SDD

SDD 方法通过三个强大的命令得到显著增强，这些命令自动化了规格说明 → 计划 → 任务的工作流：

### `/speckit.specify` 命令

此命令将简单的功能描述（用户提示）转换为完整的结构化规格说明，并自动进行仓库管理：

1. **自动功能编号**：扫描现有规格说明以确定下一个功能编号（例如，001、002、003）
2. **分支创建**：从您的描述生成语义分支名称并自动创建
3. **基于模板的生成**：复制并使用您的需求自定义功能规格说明模板
4. **目录结构**：为所有相关文档创建正确的 `specs/[branch-name]/` 结构

### `/speckit.plan` 命令

一旦功能规格说明存在，此命令将创建全面的实现计划：

1. **规格说明分析**：阅读并理解功能需求、用户故事和验收标准
2. **宪法合规**：确保与项目宪法和架构原则保持一致
3. **技术转换**：将业务需求转换为技术架构和实现细节
4. **详细文档**：为数据模型、API 契约和测试场景生成支持文档
5. **快速入门验证**：生成捕获关键验证场景的快速入门指南

### `/speckit.tasks` 命令

创建计划后，此命令分析计划和相关设计文档以生成可执行的任务列表：

1. **输入**：读取 `plan.md`（必需）以及（如果存在）`data-model.md`、`contracts/` 和 `research.md`
2. **任务推导**：将契约、实体和场景转换为具体任务
3. **并行化**：标记独立任务为 `[P]` 并概述安全的并行组
4. **输出**：在功能目录中写入 `tasks.md`，准备由任务代理执行

### 示例：构建聊天功能

以下是这些命令如何改变传统开发工作流：

**传统方法：**

```text
1. 在文档中编写 PRD（2-3 小时）
2. 创建设计文档（2-3 小时）
3. 手动设置项目结构（30 分钟）
4. 编写技术规格说明（3-4 小时）
5. 创建测试计划（2 小时）
总计：约 12 小时的文档工作
```

**使用命令的 SDD 方法：**

```bash
# 步骤 1：创建功能规格说明（5 分钟）
/speckit.specify 具有消息历史和用户在线状态的实时聊天系统

# 这会自动：
# - 创建分支 "003-chat-system"
# - 生成 specs/003-chat-system/spec.md
# - 用结构化需求填充它

# 步骤 2：生成实现计划（5 分钟）
/speckit.plan WebSocket 用于实时消息，PostgreSQL 用于历史记录，Redis 用于在线状态

# 步骤 3：生成可执行任务（5 分钟）
/speckit.tasks

# 这会自动创建：
# - specs/003-chat-system/plan.md
# - specs/003-chat-system/research.md（WebSocket 库比较）
# - specs/003-chat-system/data-model.md（消息和用户模式）
# - specs/003-chat-system/contracts/（WebSocket 事件，REST 端点）
# - specs/003-chat-system/quickstart.md（关键验证场景）
# - specs/003-chat-system/tasks.md（从计划派生的任务列表）
```

在 15 分钟内，您拥有：

- 包含用户故事和验收标准的完整功能规格说明
- 包含技术选择和理由的详细实现计划
- 准备用于代码生成的 API 契约和数据模型
- 用于自动化和手动测试的全面测试场景
- 所有文档在功能分支中正确版本化

### 结构化自动化的力量

这些命令不仅仅节省时间——它们强制执行一致性和完整性：

1. **没有遗忘的细节**：模板确保每个方面都被考虑，从非功能性需求到错误处理
2. **可追溯的决策**：每个技术选择都链接回特定的需求
3. **活文档**：规格说明与代码保持同步，因为它们生成代码
4. **快速迭代**：在几分钟内更改需求并重新生成计划，而不是几天

这些命令通过将规格说明视为可执行工件而不是静态文档来体现 SDD 原则。它们将规格说明过程从必要之恶转变为开发的驱动力。

### 模板驱动的质量：结构如何约束 LLM 以获得更好的结果

这些命令的真正力量不仅在于自动化，还在于模板如何引导 LLM 行为以生成更高质量的规格说明。模板充当复杂的提示，以有效的方式约束 LLM 的输出：

#### 1. **防止过早的实现细节**

功能规格说明模板明确指示：

```text
- ✅ 专注于用户需要什么以及为什么
- ❌ 避免如何实现（没有技术栈、API、代码结构）
```

此约束迫使 LLM 保持适当的抽象级别。当 LLM 可能自然地跳到"使用 React 和 Redux 实现"时，模板使其专注于"用户需要实时更新他们的数据"。这种分离确保规格说明即使在实现技术变化时也保持稳定。

#### 2. **强制显式不确定性标记**

两个模板都要求使用 `[NEEDS CLARIFICATION]` 标记：

```text
从用户提示创建此规格说明时：
1. **标记所有歧义**：使用 [NEEDS CLARIFICATION: 具体问题]
2. **不要猜测**：如果提示没有指定某些内容，标记它
```

这防止了 LLM 做出看似合理但可能不正确的假设的常见行为。LLM 不会猜测"登录系统"使用电子邮件/密码认证，而是必须标记为 `[NEEDS CLARIFICATION: 未指定认证方法 - 电子邮件/密码、SSO、OAuth？]`。

#### 3. **通过清单进行结构化思考**

模板包括全面的清单，作为规格说明的"单元测试"：

```markdown
### 需求完整性

- [ ] 没有剩余的 [NEEDS CLARIFICATION] 标记
- [ ] 需求可测试且明确
- [ ] 成功标准可衡量
```

这些清单迫使 LLM 系统地自我审查其输出，捕获可能遗漏的差距。这就像给 LLM 一个质量保证框架。

#### 4. **通过关卡实现宪法合规**

实现计划模板通过阶段关卡强制执行架构原则：

```markdown
### 阶段 -1：实现前关卡

#### 简单性关卡（第七条）

- [ ] 使用 ≤3 个项目？
- [ ] 没有过度设计？

#### 反抽象关卡（第八条）

- [ ] 直接使用框架？
- [ ] 单一模型表示？
```

这些关卡通过让 LLM 明确证明任何复杂性来防止过度工程。如果关卡失败，LLM 必须在"复杂性跟踪"部分记录原因，为架构决策创建责任。

#### 5. **分层细节管理**

模板强制执行正确的信息架构：

```text
**重要**：此实现计划应保持高级别和可读性。
任何代码示例、详细算法或广泛的技术规格说明
必须放在适当的 `implementation-details/` 文件中
```

这防止了规格说明变成不可读的代码堆的常见问题。LLM 学会保持适当的细节级别，将复杂性提取到单独的文件中，同时保持主文档的可导航性。

#### 6. **测试优先思维**

实现模板强制执行测试优先开发：

```text
### 文件创建顺序
1. 使用 API 规格说明创建 `contracts/`
2. 按顺序创建测试文件：契约 → 集成 → e2e → 单元
3. 创建源文件以使测试通过
```

此顺序约束确保 LLM 在实现之前考虑可测试性和契约，从而产生更健壮和可验证的规格说明。

#### 7. **防止推测性功能**

模板明确不鼓励推测：

```text
- [ ] 没有推测性或"可能需要"的功能
- [ ] 所有阶段都有明确的先决条件和可交付成果
```

这阻止 LLM 添加使实现复杂化的"锦上添花"功能。每个功能都必须追溯到具有明确验收标准的具体用户故事。

### 复合效应

这些约束共同作用，产生以下规格说明：

- **完整**：清单确保没有遗漏
- **明确**：强制澄清标记突出不确定性
- **可测试**：测试优先思维融入流程
- **可维护**：适当的抽象级别和信息层次
- **可实现**：具有具体可交付成果的明确阶段

模板将 LLM 从创意作家转变为纪律严明的规格说明工程师，将其能力引导到产生始终如一的高质量、可执行的规格说明，真正驱动开发。

## 宪法基础：强制执行架构纪律

SDD 的核心是一部宪法——一套不可变的原则，管理规格说明如何变成代码。宪法（`memory/constitution.md`）充当系统的架构 DNA，确保每个生成的实现保持一致性、简单性和质量。

### 开发的九条款

宪法定义了九条款，塑造开发过程的每个方面：

#### 第一条：库优先原则

每个功能都必须作为独立库开始——没有例外。这从一开始就强制模块化设计：

```text
Specify 中的每个功能都必须作为独立库开始其存在。
任何功能都不得直接在应用程序代码中实现，而不先
被抽象为可重用的库组件。
```

此原则确保规格说明生成模块化、可重用的代码，而不是单体应用程序。当 LLM 生成实现计划时，它必须将功能构建为具有明确边界和最小依赖的库。

#### 第二条：CLI 接口要求

每个库都必须通过命令行接口公开其功能：

```text
所有 CLI 接口必须：
- 接受文本作为输入（通过 stdin、参数或文件）
- 产生文本作为输出（通过 stdout）
- 支持 JSON 格式用于结构化数据交换
```

这强制执行可观察性和可测试性。LLM 不能将功能隐藏在不透明的类中——一切都必须通过基于文本的接口可访问和可验证。

#### 第三条：测试优先命令

最具变革性的条款——测试前无代码：

```text
这是不可协商的：所有实现都必须遵循严格的测试驱动开发。
在以下条件满足之前，不得编写任何实现代码：
1. 编写单元测试
2. 测试经过验证并获得用户批准
3. 确认测试失败（红色阶段）
```

这完全颠覆了传统的 AI 代码生成。LLM 不是生成代码并希望它能工作，而是必须首先生成定义行为的全面测试，获得批准，然后才生成实现。

#### 第七条和第八条：简单性和反抽象

这对配对的条款对抗过度工程：

```text
第 7.3 节：最小项目结构
- 初始实现最多 3 个项目
- 额外项目需要记录的理由

第 8.1 节：框架信任
- 直接使用框架功能而不是包装它们
```

当 LLM 可能自然地创建精心设计的抽象时，这些条款迫使它证明每一层复杂性的合理性。实现计划模板的"阶段 -1 关卡"直接强制执行这些原则。

#### 第九条：集成优先测试

优先考虑真实世界测试而非孤立的单元测试：

```text
测试必须使用真实环境：
- 优先使用真实数据库而非模拟
- 使用实际服务实例而非存根
- 实现前必须进行契约测试
```

这确保生成的代码在实践中工作，而不仅仅是理论上。

### 通过模板强制执行宪法

实现计划模板通过具体的检查点使这些条款可操作：

```markdown
### 阶段 -1：实现前关卡

#### 简单性关卡（第七条）

- [ ] 使用 ≤3 个项目？
- [ ] 没有过度设计？

#### 反抽象关卡（第八条）

- [ ] 直接使用框架？
- [ ] 单一模型表示？

#### 集成优先关卡（第九条）

- [ ] 定义了契约？
- [ ] 编写了契约测试？
```

这些关卡充当架构原则的编译时检查。LLM 不能在没有通过关卡或在"复杂性跟踪"部分记录合理例外的情况下继续。

### 不可变原则的力量

宪法的力量在于其不可变性。虽然实现细节可以演变，但核心原则保持不变。这提供了：

1. **跨时间的一致性**：今天生成的代码遵循与明年生成的代码相同的原则
2. **跨 LLM 的一致性**：不同的 AI 模型产生架构兼容的代码
3. **架构完整性**：每个功能都加强而不是破坏系统设计
4. **质量保证**：测试优先、库优先和简单性原则确保可维护的代码

### 宪法演进

虽然原则是不可变的，但它们的应用可以演变：

```text
第 4.2 节：修订流程
对此宪法的修改需要：
- 明确记录变更的理由
- 项目维护者的审查和批准
- 向后兼容性评估
```

这允许方法论学习和改进，同时保持稳定性。宪法通过带日期的修订展示其自身演变，展示原则如何基于实际经验进行改进。

### 超越规则：开发哲学

宪法不仅仅是一本规则手册——它是一种哲学，塑造 LLM 如何思考代码生成：

- **可观察性优于不透明性**：一切都必须通过 CLI 接口可检查
- **简单性优于聪明**：从简单开始，只有在证明必要时才添加复杂性
- **集成优于隔离**：在真实环境中测试，而不是人工环境
- **模块化优于单体**：每个功能都是具有明确边界的库

通过将这些原则嵌入规格说明和计划过程，SDD 确保生成的代码不仅仅是功能性的——它是可维护、可测试和架构健全的。宪法将 AI 从代码生成器转变为尊重和加强系统设计原则的架构合作伙伴。

## 转型

这不是要取代开发人员或自动化创造力。这是关于通过自动化机械翻译来放大人类能力。这是关于创建一个紧密的反馈循环，其中规格说明、研究和代码一起演变，每次迭代都带来更深的理解和意图与实现之间更好的对齐。

软件开发需要更好的工具来保持意图和实现之间的对齐。SDD 提供了通过生成代码而不仅仅是指导代码的可执行规格说明来实现这种对齐的方法论。
